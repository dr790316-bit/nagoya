<script type="module">
import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js';
import { getDatabase, ref as dbRef, set, onValue, push, update, remove } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-database.js';
import { getStorage, ref as storageRef, uploadString, getDownloadURL } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-storage.js';
// ★ 新增：引入驗證模組
import { getAuth, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js';

const firebaseConfig = {
  apiKey: "AIzaSyDRtLqLIPtLB7WmGqwbS4YjRHpDRF8Rv0g",
  authDomain: "nagoya-snow-tour.firebaseapp.com",
  databaseURL: "https://nagoya-snow-tour-default-rtdb.asia-southeast1.firebasedatabase.app",
  projectId: "nagoya-snow-tour",
  storageBucket: "nagoya-snow-tour.firebasestorage.app",
  messagingSenderId: "189759409360",
  appId: "1:189759409360:web:26ef01e7ae294a1222a2d5",
  measurementId: "G-PS3ZL41FYT"
};

try {
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const storage = getStorage(app);
    
    // ★ 新增：初始化 Auth 並執行匿名登入
    const auth = getAuth(app);
    signInAnonymously(auth)
        .then(() => {
            console.log("✅ Firebase 匿名登入成功 (Authenticated)");
        })
        .catch((error) => {
            console.error("❌ 登入失敗:", error);
        });

    window.firebaseDb = db; 
    window.firebaseStorage = storage;
} catch (error) {
    console.error("Firebase Init Error:", error);
    window.firebaseDb = null;
    window.firebaseStorage = null;
}

const db = window.firebaseDb;
const storage = window.firebaseStorage;
const { createApp, ref, computed, onMounted, watch, nextTick } = Vue;

createApp({
    setup() {
        const isRemoteUpdate = ref(false);
        const isLoading = ref(true);
        const loadingTooLong = ref(false);
        const isSubmitting = ref(false); 
        const currentUser = ref(null);
        const isLocked = ref(false); 
        const isOnline = ref(navigator.onLine);
        const isFirebaseReady = ref(false);

        const currentTab = ref('traffic');
        const tabNameMap = { 'traffic': '交通', 'split': '分帳', 'map': '地圖', 'accounting': '記帳', 'info': '資訊' };
        
        const currentDay = ref(1);
        const days = ref([1, 2, 3, 4, 5, 6, 7]); 
        const showTrafficModal = ref(false);
        const isEditingTraffic = ref(false);
        const editingTrafficId = ref(null);
        const toast = ref({ show: false, message: '', icon: '' });
        const confirmModal = ref({ show: false, title: '', message: '', targetId: null, targetType: '' });
        const expenseActionModal = ref({ show: false, item: {} }); 
        const fixedMembers = ['明學', '嘉旺', '郡哲', '柏翰', '聿玄', '常駐', '厚仁', '婉瑜'];
        const showImageModal = ref(false);
        const viewImageSrc = ref('');
        const cityCoords = { 'Nagoya': { lat: 35.1815, lon: 136.9066 }, 'Takayama': { lat: 36.1407, lon: 137.2595 }, 'Shirakawa': { lat: 36.2566, lon: 136.9043 }, 'Kanazawa': { lat: 36.5613, lon: 136.6562 } };
        
        const trafficList = ref([]);
        const members = ref([...fixedMembers]);
        const expenses = ref([]);
        const locations = ref([]);
        const exchangeRate = ref(0.215); 
        const shoppingList = ref([]);
        const showShoppingModal = ref(false);
        const isEditingShopping = ref(false);
        const editingShoppingId = ref(null);
        const shoppingModalData = ref({ name: '', description: '', image: '', owner: '', link: '', isBought: false });
        const currentShoppingMember = ref(null);
        const currencyMode = ref('JPY'); 
        const weatherCity = ref('Nagoya');
        const weatherData = ref({});
        const editingExpenseId = ref(null); 
        const selectedDateFilter = ref('ALL'); 
        
        // Accounting & Private Expense
        const userBudgets = ref({}); 
        const myBudgetTWD = ref(0); 
        const showPersonalExpenseModal = ref(false);
        const personalExpenseData = ref({ description: '', amount: '', category: 'shopping' });
        const accountingDateFilter = ref('ALL');
        const showSettleModal = ref(false);
        const settleData = ref({ from: '', to: '', amount: 0, currency: 'TWD', type: 'pay', targetName: '' });
        const showHistoryModal = ref(false);
        const historyList = ref([]);
        const historyTargetName = ref('');

        const categories = ref([
            { id: 'food', name: '飲食', icon: 'fa-solid fa-utensils', color: 'bg-orange-400' },
            { id: 'transport', name: '交通', icon: 'fa-solid fa-train-subway', color: 'bg-blue-400' },
            { id: 'shopping', name: '購物', icon: 'fa-solid fa-bag-shopping', color: 'bg-pink-400' },
            { id: 'ticket', name: '票券', icon: 'fa-solid fa-ticket', color: 'bg-purple-400' },
            { id: 'hotel', name: '住宿', icon: 'fa-solid fa-bed', color: 'bg-indigo-400' },
            { id: 'other', name: '其他', icon: 'fa-solid fa-shapes', color: 'bg-stone-400' }
        ]);

        const costViewMode = ref('payer');

        const newExpense = ref({ description: '', inputAmount: '', payer: '', image: '', beneficiaries: [...fixedMembers], category: 'food' });
        
        const trafficModalData = ref({ time: '09:00', endTime: '', type: 'train', destination: '', description: '', url: '', ticketUrl: '' }); 
        const msgContainer = ref(null);
        const selectedPayerForDetail = ref(fixedMembers[0]);
        const locationModalData = ref({ name: '', description: '', url: '' });
        const showLocationModal = ref(false);
        const isEditingLocation = ref(false);
        const editingLocationId = ref(null);

        const TRIP_START_DATE = new Date('2025-12-30T00:00:00+09:00');

        const getJapanDateObj = () => {
            const date = new Date();
            const jstString = date.toLocaleString('en-US', { timeZone: 'Asia/Tokyo' });
            return new Date(jstString);
        };
        
        const getJapanDateStr = () => getJapanDateObj().toLocaleDateString('zh-TW');
        const getJapanTimeStr = () => getJapanDateObj().toLocaleTimeString('zh-TW', { hour12: false, hour: '2-digit', minute: '2-digit' });

        const showToast = (msg, type = 'success') => { toast.value = { show: true, message: msg, icon: type === 'error' ? 'fa-solid fa-circle-exclamation' : 'fa-solid fa-clover' }; setTimeout(() => { toast.value.show = false; }, 3000); };
        const openImageModal = (src) => { viewImageSrc.value = src; showImageModal.value = true; };
        
        // Lock body scroll when any modal is open
        const anyModalOpen = computed(() => showImageModal.value || confirmModal.value.show || expenseActionModal.value.show || showPersonalExpenseModal.value || showSettleModal.value || showHistoryModal.value || showTrafficModal.value || showLocationModal.value || showShoppingModal.value);
        watch(anyModalOpen, (val) => {
            if (val) document.body.classList.add('modal-open');
            else document.body.classList.remove('modal-open');
        });

        // Network Status Listeners
        window.addEventListener('online', () => { isOnline.value = true; showToast('網路已恢復', 'success'); });
        window.addEventListener('offline', () => { isOnline.value = false; showToast('網路已斷開，進入離線模式', 'error'); });

        const fetchRealTimeExchangeRate = async () => {
            if(!isOnline.value) return;
            try {
                const res = await fetch('https://api.exchangerate-api.com/v4/latest/JPY');
                const data = await res.json();
                if(data && data.rates && data.rates.TWD) exchangeRate.value = parseFloat(data.rates.TWD.toFixed(3));
            } catch(e) {}
        };

        const processImage = (file, callback) => {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const MAX_WIDTH = 800; 
                    let width = img.width;
                    let height = img.height;
                    if (width > MAX_WIDTH) { height *= MAX_WIDTH / width; width = MAX_WIDTH; }
                    canvas.width = width; canvas.height = height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, width, height);
                    callback(canvas.toDataURL('image/jpeg', 0.6));
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        };

        const uploadImageToStorage = async (base64String, folderName) => {
            if (!base64String || !storage || !isOnline.value) return base64String; 
            if (base64String.startsWith('http')) return base64String;

            try {
                const fileName = `${folderName}/${Date.now()}.jpg`;
                const imageRef = storageRef(storage, fileName);
                await uploadString(imageRef, base64String, 'data_url');
                const downloadURL = await getDownloadURL(imageRef);
                return downloadURL;
            } catch (error) {
                console.error("Upload failed:", error);
                showToast("圖片上傳失敗(離線)", "error");
                return base64String; 
            }
        };

        const setUser = (name) => {
            currentUser.value = name;
            localStorage.setItem('nagoya_user', name);
            newExpense.value.payer = name;
            shoppingModalData.value.owner = name;
            if (userBudgets.value && userBudgets.value[name]) {
                myBudgetTWD.value = userBudgets.value[name];
            } else {
                myBudgetTWD.value = 0;
            }
            currentShoppingMember.value = name;
        };
        
        const confirmLogout = () => { if(confirm("切換使用者?")) { currentUser.value = null; localStorage.removeItem('nagoya_user'); } };
        
        const toggleGlobalLock = () => {
            if(db) set(dbRef(db, 'global_settings/is_locked'), !isLocked.value);
        };

        const saveBudget = () => {
            if (currentUser.value) {
                if(!userBudgets.value) userBudgets.value = {};
                userBudgets.value[currentUser.value] = myBudgetTWD.value;
            }
        };

        // Load Local Data (Fallback)
        const loadLocalData = () => {
            try {
                if(localStorage.getItem('traffic')) trafficList.value = JSON.parse(localStorage.getItem('traffic'));
                if(localStorage.getItem('expenses')) expenses.value = JSON.parse(localStorage.getItem('expenses'));
                if(localStorage.getItem('locations')) locations.value = JSON.parse(localStorage.getItem('locations'));
                if(localStorage.getItem('shopping_list')) shoppingList.value = JSON.parse(localStorage.getItem('shopping_list'));
                if(localStorage.getItem('exchangeRate')) exchangeRate.value = parseFloat(localStorage.getItem('exchangeRate'));
                if(localStorage.getItem('userBudgets')) userBudgets.value = JSON.parse(localStorage.getItem('userBudgets'));
                console.log("Loaded local data");
            } catch(e) { console.error('Local Load Error', e); }
        };

        onMounted(() => {
            const savedUser = localStorage.getItem('nagoya_user');
            if(savedUser && members.value.includes(savedUser)) setUser(savedUser);
            
            // Timeout safety for poor connection
            setTimeout(() => {
                if(isLoading.value) {
                    loadingTooLong.value = true;
                }
            }, 3000);

            // Force load local if firebase hangs for 5 seconds
            setTimeout(() => {
                if(isLoading.value) {
                    isLoading.value = false;
                    loadLocalData();
                    isFirebaseReady.value = true; 
                    showToast('網路逾時，使用離線資料', 'error');
                }
            }, 6000);

            if(db) {
                let loadCheck = 0;
                const checkLoad = () => { 
                    loadCheck++; 
                    if(loadCheck >= 2) { 
                        isLoading.value = false;
                        isFirebaseReady.value = true;
                    } 
                };
                
                const handleRemoteUpdate = (refValue, targetRef) => {
                    const val = refValue || [];
                    if (JSON.stringify(targetRef.value) !== JSON.stringify(val)) {
                        isRemoteUpdate.value = true;
                        targetRef.value = val;
                        nextTick(() => { isRemoteUpdate.value = false; });
                    }
                };

                onValue(dbRef(db, 'traffic'), (s) => { handleRemoteUpdate(s.val(), trafficList); checkLoad(); });
                onValue(dbRef(db, 'expenses'), (s) => { handleRemoteUpdate(s.val(), expenses); checkLoad(); });
                onValue(dbRef(db, 'locations'), (s) => { handleRemoteUpdate(s.val(), locations); });
                onValue(dbRef(db, 'shopping_list'), (s) => { handleRemoteUpdate(s.val(), shoppingList); });
                onValue(dbRef(db, 'budgets'), (s) => { 
                    const val = s.val() || {};
                    userBudgets.value = val;
                    if(currentUser.value && val[currentUser.value]) myBudgetTWD.value = val[currentUser.value];
                });
                
                onValue(dbRef(db, 'exchangeRate'), (s) => { if(s.val()) exchangeRate.value = parseFloat(s.val()); });
                onValue(dbRef(db, 'global_settings/is_locked'), (s) => { isLocked.value = !!s.val(); });
            } else {
                loadLocalData();
                isLoading.value = false;
            }

            fetchRealTimeExchangeRate();
            fetchWeather();
        });

        const createWatcher = (source, storageKey, dbPath) => {
            watch(source, (v) => {
                if (isRemoteUpdate.value) return;
                localStorage.setItem(storageKey, JSON.stringify(v));
                if(db && isFirebaseReady.value) set(dbRef(db, dbPath), v);
            }, { deep: true });
        };

        createWatcher(trafficList, 'traffic', 'traffic');
        createWatcher(expenses, 'expenses', 'expenses');
        createWatcher(locations, 'locations', 'locations');
        createWatcher(shoppingList, 'shopping_list', 'shopping_list');
        createWatcher(userBudgets, 'userBudgets', 'budgets');

        watch(exchangeRate, (v) => { localStorage.setItem('exchangeRate', v); if(db) set(dbRef(db, 'exchangeRate'), v); });

        const filteredTraffic = computed(() => trafficList.value.filter(item => item.day === currentDay.value).sort((a, b) => a.time.localeCompare(b.time)));
        const publicExpenses = computed(() => expenses.value.filter(e => !e.isPrivate));
        const totalExpense = computed(() => publicExpenses.value.filter(e => e.type !== 'repayment').reduce((sum, item) => sum + item.amount, 0));
        const calculatedTWD = computed(() => !newExpense.value.inputAmount ? 0 : (currencyMode.value === 'JPY' ? Math.round(newExpense.value.inputAmount * exchangeRate.value) : Math.round(newExpense.value.inputAmount)));
        
        const isToday = computed(() => {
            const now = new Date(); 
            const diffTime = now.getTime() - TRIP_START_DATE.getTime();
            if(diffTime < 0) return false;
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24)) + 1; 
            return diffDays === currentDay.value;
        }); 
        
        const currentTimePercent = computed(() => {
            const japanDate = getJapanDateObj();
            const h = japanDate.getHours();
            const m = japanDate.getMinutes();
            const totalMinutes = 18 * 60;
            const currentMinutes = (h * 60 + m) - (6 * 60);
            const pct = (currentMinutes / totalMinutes) * 100;
            return Math.max(0, Math.min(100, pct));
        });

        const debts = computed(() => {
            if (members.value.length === 0) return [];
            
            let debtMatrix = {};
            members.value.forEach(m => {
                debtMatrix[m] = {};
                members.value.forEach(m2 => debtMatrix[m][m2] = 0);
            });

            publicExpenses.value.forEach(e => {
                if (e.type === 'repayment') {
                    if (e.beneficiaries && e.beneficiaries.length > 0) {
                        debtMatrix[e.beneficiaries[0]][e.payer] += e.amount;
                    }
                    return;
                }

                let targets = (e.beneficiaries && e.beneficiaries.length > 0) ? e.beneficiaries : members.value;
                let split = e.amount / targets.length;
                
                targets.forEach(t => {
                    if (t !== e.payer) {
                        debtMatrix[t][e.payer] += split;
                    }
                });
            });

            let result = [];
            for (let i = 0; i < members.value.length; i++) {
                for (let j = i + 1; j < members.value.length; j++) {
                    let m1 = members.value[i];
                    let m2 = members.value[j];
                    
                    let val1 = debtMatrix[m1][m2]; 
                    let val2 = debtMatrix[m2][m1]; 
                    
                    let net = val1 - val2;
                    
                    if (net > 1) { result.push({ from: m1, to: m2, amount: net }); } 
                    else if (net < -1) { result.push({ from: m2, to: m1, amount: -net }); }
                }
            }
            return result.sort((a,b) => b.amount - a.amount);
        });

        const currentDetailList = computed(() => {
            if (!selectedPayerForDetail.value) return [];
            if (costViewMode.value === 'payer') {
                return publicExpenses.value.filter(e => e.payer === selectedPayerForDetail.value).slice().reverse();
            } else {
                return publicExpenses.value.filter(e => {
                    if (e.type === 'repayment') return false;
                    const ben = (e.beneficiaries && e.beneficiaries.length > 0) ? e.beneficiaries : members.value;
                    return ben.includes(selectedPayerForDetail.value);
                }).slice().reverse();
            }
        });

        const getMyShare = (exp, user) => {
            const ben = (exp.beneficiaries && exp.beneficiaries.length > 0) ? exp.beneficiaries : members.value;
            if (ben.includes(user)) {
                return exp.amount / ben.length;
            }
            return 0;
        };

        const currentDetailTotal = computed(() => {
            return currentDetailList.value.reduce((sum, item) => {
                if (costViewMode.value === 'payer') return sum + item.amount;
                else return sum + getMyShare(item, selectedPayerForDetail.value);
            }, 0);
        });

        const categoryAnalysis = computed(() => {
            const total = totalExpense.value;
            if (total === 0) return [];
            
            const catTotals = {};
            categories.value.forEach(c => catTotals[c.id] = 0);
            
            publicExpenses.value.forEach(e => {
                if (e.type === 'repayment') return;
                const cat = e.category || 'other';
                if (catTotals[cat] !== undefined) catTotals[cat] += e.amount;
                else {
                    if(!catTotals['other']) catTotals['other'] = 0;
                    catTotals['other'] += e.amount;
                }
            });

            return categories.value.map(c => ({
                id: c.id,
                name: c.name,
                color: c.color,
                percent: (catTotals[c.id] / total) * 100
            })).filter(c => c.percent > 0).sort((a,b) => b.percent - a.percent);
        });

        const myCategoryAnalysis = computed(() => {
            const total = myTotalSpentTWD.value;
            if (total === 0) return [];
            
            const catTotals = {};
            categories.value.forEach(c => catTotals[c.id] = 0);
            
            myExpenses.value.forEach(e => {
                const share = getMyShare(e, currentUser.value);
                const cat = e.category || 'other';
                if (catTotals[cat] !== undefined) catTotals[cat] += share;
                else {
                    if(!catTotals['other']) catTotals['other'] = 0;
                    catTotals['other'] += share;
                }
            });

            return categories.value.map(c => ({
                id: c.id,
                name: c.name,
                color: c.color,
                percent: (catTotals[c.id] / total) * 100
            })).filter(c => c.percent > 0).sort((a,b) => b.percent - a.percent);
        });

        const uniqueDates = computed(() => {
            const dates = new Set(expenses.value.map(e => e.date)); 
            return Array.from(dates).sort((a, b) => new Date(b) - new Date(a));
        });

        const filteredHistory = computed(() => {
            let list = publicExpenses.value.slice().reverse();
            if (selectedDateFilter.value !== 'ALL') {
                list = list.filter(e => e.date === selectedDateFilter.value);
            }
            return list;
        });

        const dailyTotal = computed(() => {
            if (selectedDateFilter.value === 'ALL') return 0;
            return filteredHistory.value.reduce((sum, item) => sum + item.amount, 0);
        });

        const myExpenses = computed(() => {
            if (!currentUser.value) return [];
            return expenses.value.filter(e => {
                if (e.type === 'repayment') return false;
                
                if (e.isPrivate) {
                    return e.payer === currentUser.value;
                } else {
                    const ben = (e.beneficiaries && e.beneficiaries.length > 0) ? e.beneficiaries : members.value;
                    return ben.includes(currentUser.value);
                }
            }).slice().reverse();
        });

        const filteredMyExpenses = computed(() => {
            let list = myExpenses.value;
            if (accountingDateFilter.value !== 'ALL') {
                list = list.filter(e => e.date === accountingDateFilter.value);
            }
            return list;
        });

        const myDailyTotal = computed(() => {
            if (accountingDateFilter.value === 'ALL') return 0;
            return filteredMyExpenses.value.reduce((sum, e) => sum + getMyShare(e, currentUser.value), 0);
        });

        const myTotalSpentTWD = computed(() => {
            return myExpenses.value.reduce((sum, e) => sum + getMyShare(e, currentUser.value), 0);
        });

        const myRemaining = computed(() => {
            return myBudgetTWD.value - myTotalSpentTWD.value;
        });

        const progressBarColor = computed(() => {
            const pct = (myRemaining.value / (myBudgetTWD.value || 1)) * 100;
            if(pct >= 75) return 'bg-blue-400';
            if(pct >= 50) return 'bg-clover-500';
            if(pct >= 25) return 'bg-yellow-400';
            return 'bg-red-400';
        });

        const myDebts = computed(() => {
            if(!currentUser.value) return [];
            return debts.value.filter(d => d.from === currentUser.value || d.to === currentUser.value);
        });

        const savePersonalExpense = async () => {
            if (!personalExpenseData.value.amount || !personalExpenseData.value.description) {
                showToast('請輸入完整資訊', 'error'); return;
            }
            isSubmitting.value = true;
            try {
                const amountTWD = Math.round(personalExpenseData.value.amount * exchangeRate.value); 
                const expenseData = {
                    description: personalExpenseData.value.description,
                    originalAmount: personalExpenseData.value.amount,
                    originalCurrency: 'JPY',
                    amount: amountTWD,
                    payer: currentUser.value,
                    date: getJapanDateStr(),
                    beneficiaries: [currentUser.value],
                    category: personalExpenseData.value.category,
                    isPrivate: true,
                    type: 'expense'
                };
                expenses.value.push(expenseData);
                showToast('已新增個人支出');
                showPersonalExpenseModal.value = false;
                personalExpenseData.value = { description: '', amount: '', category: 'shopping' };
            } catch(e) { console.error(e); } 
            finally { isSubmitting.value = false; }
        };

        const calcJPYFromTWD = (amountTWD) => {
            return Math.round(amountTWD / exchangeRate.value);
        };

        const filteredShoppingList = computed(() => !currentShoppingMember.value ? shoppingList.value : shoppingList.value.filter(item => item.owner === currentShoppingMember.value));
        const sortedShoppingList = computed(() => [...filteredShoppingList.value].sort((a, b) => (a.isBought === b.isBought) ? 0 : a.isBought ? 1 : -1));

        const askDelete = (type, id) => { confirmModal.value = { show: true, title: 'Delete Item?', message: 'Are you sure?', targetId: id, targetType: type }; };
        const confirmAction = () => {
            const { targetType, targetId } = confirmModal.value;
            if (targetType === 'traffic') trafficList.value = trafficList.value.filter(x => x.id !== targetId);
            else if (targetType === 'expense') {}
            else if (targetType === 'location') locations.value = locations.value.filter(l => l.id !== targetId);
            else if (targetType === 'shopping') shoppingList.value = shoppingList.value.filter(l => l.id !== targetId);
            confirmModal.value.show = false; showToast('Item deleted');
        };

        const handleExpenseImage = (event) => processImage(event.target.files[0], (d) => newExpense.value.image = d);
        const handleImageUpload = (event) => processImage(event.target.files[0], (d) => shoppingModalData.value.image = d);

        const openTrafficModal = () => { isEditingTraffic.value = false; editingTrafficId.value = null; trafficModalData.value = { time: '09:00', endTime: '', type: 'train', destination: '', description: '', url: '', ticketUrl: '' }; showTrafficModal.value = true; };
        const editTraffic = (item) => { isEditingTraffic.value = true; editingTrafficId.value = item.id; trafficModalData.value = { ...item }; showTrafficModal.value = true; };
        const copyTraffic = (item) => { const newItem = { ...item, id: Date.now() }; trafficList.value.push(newItem); showToast('Item copied'); };
        const saveTraffic = () => {
            if (!trafficModalData.value.destination) { showToast('Please enter destination', 'error'); return; }
            if (isEditingTraffic.value) { const idx = trafficList.value.findIndex(x => x.id === editingTrafficId.value); if (idx !== -1) trafficList.value[idx] = { ...trafficModalData.value, id: editingTrafficId.value, day: currentDay.value }; } 
            else trafficList.value.push({ id: Date.now(), day: currentDay.value, ...trafficModalData.value });
            showTrafficModal.value = false; showToast('Saved');
        };
        const getTransportIcon = (t) => ({ 'plane': 'fa-solid fa-plane', 'train': 'fa-solid fa-train', 'bus': 'fa-solid fa-bus', 'taxi': 'fa-solid fa-taxi', 'walk': 'fa-solid fa-person-walking' }[t] || 'fa-solid fa-diamond-turn-right');

        const toggleBeneficiary = (m) => {
            const idx = newExpense.value.beneficiaries.indexOf(m);
            if(idx > -1) newExpense.value.beneficiaries.splice(idx, 1);
            else newExpense.value.beneficiaries.push(m);
        };

        const toggleAllBeneficiaries = () => {
            if(newExpense.value.beneficiaries.length === members.value.length) newExpense.value.beneficiaries = [];
            else newExpense.value.beneficiaries = [...members.value];
        };

        const openExpenseAction = (item) => {
            if(isLocked.value) return;
            expenseActionModal.value = { show: true, item: item };
        };

        const triggerEditExpense = () => {
            const item = expenseActionModal.value.item;
            editingExpenseId.value = item; 
            newExpense.value = {
                description: item.description,
                inputAmount: item.originalAmount || item.amount,
                payer: item.payer,
                image: item.image || '',
                beneficiaries: item.beneficiaries ? [...item.beneficiaries] : [...members.value],
                category: item.category || 'other',
                isPrivate: item.isPrivate || false 
            };
            currencyMode.value = item.originalCurrency || 'TWD';
            
            if (currentTab.value === 'accounting') {
                currentTab.value = 'split';
            }

            expenseActionModal.value.show = false;
            setTimeout(() => {
                document.getElementById('expense-form').scrollIntoView({ behavior: 'smooth' });
            }, 100);
        };

        const cancelEditExpense = () => {
            editingExpenseId.value = null;
            newExpense.value = { description: '', inputAmount: '', payer: currentUser.value || members.value[0], image: '', beneficiaries: [...members.value], category: 'food' };
        };

        const triggerDeleteExpense = () => {
             const target = expenseActionModal.value.item;
             const idx = expenses.value.findIndex(e => e === target); 
             if(idx !== -1) {
                 if(confirm("確定刪除此筆支出?")) {
                     expenses.value.splice(idx, 1);
                     expenseActionModal.value.show = false;
                     showToast('Deleted');
                 }
             }
        };

        const addExpense = async () => {
            if (!newExpense.value.description || !newExpense.value.inputAmount || !newExpense.value.payer) { showToast('Missing info', 'error'); return; }
            if (newExpense.value.inputAmount <= 0) { showToast('金額錯誤', 'error'); return; }
            if (newExpense.value.beneficiaries.length === 0) { showToast('請選擇分攤對象', 'error'); return; }
            
            isSubmitting.value = true; 
            
            try {
                let imageUrl = newExpense.value.image;
                if (imageUrl && imageUrl.startsWith('data:')) {
                     imageUrl = await uploadImageToStorage(imageUrl, 'expenses');
                }

                const currentType = (editingExpenseId.value && editingExpenseId.value.type) ? editingExpenseId.value.type : 'expense';

                const expenseData = { 
                    description: newExpense.value.description, 
                    originalAmount: newExpense.value.inputAmount, 
                    originalCurrency: currencyMode.value, 
                    amount: calculatedTWD.value, 
                    payer: newExpense.value.payer, 
                    date: editingExpenseId.value ? (editingExpenseId.value.date) : getJapanDateStr(), 
                    image: imageUrl || '',
                    beneficiaries: [...newExpense.value.beneficiaries],
                    category: newExpense.value.category || 'other', 
                    isPrivate: newExpense.value.isPrivate || false, 
                    type: currentType 
                };

                if(editingExpenseId.value) {
                    const idx = expenses.value.findIndex(e => e === editingExpenseId.value);
                    if(idx !== -1) {
                        expenses.value[idx] = expenseData;
                        showToast('Expense Updated');
                    }
                    currentTab.value = 'accounting';
                    editingExpenseId.value = null;
                } else {
                    expenses.value.push(expenseData);
                    showToast('Expense Added');
                }
                
                newExpense.value = { description: '', inputAmount: '', payer: currentUser.value || newExpense.value.payer, image: '', beneficiaries: [...members.value], category: 'food' }; 

            } catch(e) {
                console.error(e);
                showToast('Error', 'error');
            } finally {
                isSubmitting.value = false;
            }
        };

        const openSettleModal = (debt) => {
            const isPaying = debt.from === currentUser.value; 
            settleData.value = {
                from: debt.from,
                to: debt.to,
                amount: debt.amount,
                currency: 'TWD',
                type: isPaying ? 'pay' : 'receive', 
                targetName: isPaying ? debt.to : debt.from 
            };
            showSettleModal.value = true;
        };

        const confirmSettle = () => {
            if(!settleData.value.amount || settleData.value.amount <= 0) return;
            
            let finalAmount = settleData.value.amount;
            if(settleData.value.currency === 'JPY') {
                finalAmount = Math.round(settleData.value.amount * exchangeRate.value);
            }

            expenses.value.push({
                description: `還款 (${settleData.value.from} -> ${settleData.value.to})`,
                amount: finalAmount,
                originalAmount: settleData.value.amount,
                originalCurrency: settleData.value.currency,
                payer: settleData.value.from,
                date: getJapanDateStr(),
                type: 'repayment',
                category: 'other',
                beneficiaries: [settleData.value.to],
                isPrivate: false
            });
            showSettleModal.value = false;
            showToast('還款已記錄');
        };

        const openHistoryModal = (debt) => {
            const isPaying = debt.from === currentUser.value;
            historyTargetName.value = isPaying ? debt.to : debt.from;
            const target = historyTargetName.value;
            const me = currentUser.value;

            historyList.value = expenses.value.filter(e => {
                if(e.type !== 'repayment') return false;
                const isMePayer = e.payer === me;
                const isMeBen = e.beneficiaries && e.beneficiaries.includes(me);
                const isTargetPayer = e.payer === target;
                const isTargetBen = e.beneficiaries && e.beneficiaries.includes(target);
                if (isMePayer && isTargetBen) return true;
                if (isTargetPayer && isMeBen) return true;
                return false;
            }).sort((a,b) => new Date(b.date) - new Date(a.date)); 
            
            historyList.value.reverse(); 
            showHistoryModal.value = true;
        };
        
        const isAllBeneficiaries = (exp) => {
            if (!exp.beneficiaries || exp.beneficiaries.length === 0) return true; 
            return exp.beneficiaries.length === members.value.length;
        };

        const getCategoryIcon = (catId) => {
            const c = categories.value.find(c => c.id === catId);
            return c ? c.icon : 'fa-solid fa-circle-question';
        };

        const calcJPY = (exp) => {
            if (exp.originalCurrency === 'JPY') return Math.round(exp.originalAmount).toLocaleString();
            return Math.round(exp.amount / exchangeRate.value).toLocaleString();
        };

        const openLocationModal = () => { isEditingLocation.value = false; locationModalData.value = { name: '', description: '', url: '' }; showLocationModal.value = true; };
        const editLocation = (loc) => { isEditingLocation.value = true; editingLocationId.value = loc.id; locationModalData.value = { ...loc }; showLocationModal.value = true; };
        const saveLocation = () => { if(!locationModalData.value.name) { showToast('Name required', 'error'); return; } if(isEditingLocation.value) { const idx = locations.value.findIndex(l => l.id === editingLocationId.value); if(idx !== -1) locations.value[idx] = { ...locationModalData.value, id: editingLocationId.value }; } else locations.value.push({ id: Date.now(), ...locationModalData.value }); showLocationModal.value = false; showToast('Saved'); };

        const toggleShoppingMember = (m) => currentShoppingMember.value = currentShoppingMember.value === m ? null : m;
        const openShoppingModal = () => { isEditingShopping.value = false; shoppingModalData.value = { name: '', description: '', image: '', owner: currentShoppingMember.value || currentUser.value || members.value[0], link: '', isBought: false }; showShoppingModal.value = true; };
        const editShopping = (item) => { isEditingShopping.value = true; editingShoppingId.value = item.id; shoppingModalData.value = { ...item }; showShoppingModal.value = true; };
        const toggleBought = (item) => { const idx = shoppingList.value.findIndex(l => l.id === item.id); if(idx !== -1) shoppingList.value[idx] = { ...item, isBought: !item.isBought }; };
        const saveShoppingItem = async () => { 
            if(!shoppingModalData.value.name) { showToast('Name required', 'error'); return; } 
            isSubmitting.value = true;
            try {
                let imageUrl = shoppingModalData.value.image;
                if (imageUrl && imageUrl.startsWith('data:')) {
                    imageUrl = await uploadImageToStorage(imageUrl, 'shopping');
                }
                const itemData = { ...shoppingModalData.value, image: imageUrl };
                if(isEditingShopping.value) { 
                    const idx = shoppingList.value.findIndex(l => l.id === editingShoppingId.value); 
                    if(idx !== -1) shoppingList.value[idx] = { ...itemData, id: editingShoppingId.value }; 
                } else { 
                    shoppingList.value.push({ id: Date.now(), ...itemData }); 
                }
                showShoppingModal.value = false; 
                showToast('Saved');
            } catch (e) {
                console.error(e);
                showToast('Error', 'error');
            } finally {
                isSubmitting.value = false;
            }
        };

        const fetchWeather = async () => { const coords = cityCoords[weatherCity.value]; if(!coords) return; try { const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${coords.lat}&longitude=${coords.lon}&daily=weathercode,temperature_2m_max,temperature_2m_min&timezone=Asia%2FTokyo`); const json = await res.json(); if(json && json.daily) weatherData.value = json; } catch(e) { console.warn('Weather fetch failed', e); } };
        const getWeatherDay = (idx) => { const d = new Date(); d.setDate(d.getDate() + idx); return ['SUN','MON','TUE','WED','THU','FRI','SAT'][d.getDay()]; };
        const getWeatherIcon = (c) => { if (c === 0) return 'fa-solid fa-sun'; if (c <= 3) return 'fa-solid fa-cloud-sun'; if (c <= 48) return 'fa-solid fa-smog'; if (c <= 67) return 'fa-solid fa-cloud-rain'; if (c <= 77) return 'fa-regular fa-snowflake'; if (c > 80 && c < 85) return 'fa-solid fa-cloud-showers-heavy'; if (c >= 85) return 'fa-solid fa-snowflake'; return 'fa-solid fa-cloud'; };

        return {
            isLoading, loadingTooLong, isSubmitting, currentUser, setUser, isLocked, confirmLogout, toggleGlobalLock, isOnline,
            currentTab, tabNameMap, currentDay, days, members, expenses, newExpense, totalExpense, debts, addExpense, msgContainer, askDelete, confirmModal, confirmAction, exchangeRate, currencyMode, calculatedTWD, trafficList, filteredTraffic, showTrafficModal, trafficModalData, openTrafficModal, saveTraffic, editTraffic, copyTraffic, getTransportIcon, isEditingTraffic, toast, selectedPayerForDetail, locations, showLocationModal, locationModalData, openLocationModal, editLocation, saveLocation, isEditingLocation, shoppingList, showShoppingModal, shoppingModalData, openShoppingModal, editShopping, saveShoppingItem, isEditingShopping, handleImageUpload, currentShoppingMember, toggleShoppingMember, filteredShoppingList, sortedShoppingList, toggleBought, weatherCity, weatherData, fetchWeather, getWeatherDay, getWeatherIcon, handleExpenseImage, showImageModal, viewImageSrc, openImageModal,
            isToday, currentTimePercent,
            toggleBeneficiary, toggleAllBeneficiaries, isAllBeneficiaries,
            categories, costViewMode, currentDetailList, currentDetailTotal, getMyShare, categoryAnalysis, getCategoryIcon,
            expenseActionModal, openExpenseAction, triggerEditExpense, triggerDeleteExpense, editingExpenseId, cancelEditExpense, calcJPY,
            uniqueDates, selectedDateFilter, filteredHistory, dailyTotal,
            userBudgets, myBudgetTWD, saveBudget, myExpenses, myTotalSpentTWD, myRemaining, 
            showPersonalExpenseModal, personalExpenseData, savePersonalExpense,
            accountingDateFilter, filteredMyExpenses, myDailyTotal, myCategoryAnalysis, myDebts, progressBarColor, calcJPYFromTWD,
            showSettleModal, settleData, openSettleModal, confirmSettle, 
            showHistoryModal, historyList, historyTargetName, openHistoryModal
        };
    }
}).mount('#app');
</script>